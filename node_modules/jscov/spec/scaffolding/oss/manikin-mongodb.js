// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var async, getKeys, massage, massageCore, massageOne, massaged, preprocFilter, propagate, tools, _,
    __slice = [].slice;

  async = require('async');

  _ = require('underscore');

  tools = require('./manikin-tools');

  preprocFilter = function(filter) {
    var x;
    x = _.extend({}, filter);
    if (x.id) {
      x._id = x.id;
    }
    delete x.id;
    return x;
  };

  massageOne = function(x) {
    if (!(x != null)) {
      return x;
    }
    x.id = x._id;
    delete x._id;
    return x;
  };

  massageCore = function(r2) {
    if (Array.isArray(r2)) {
      return r2.map(massageOne);
    } else {
      return massageOne(r2);
    }
  };

  massage = function(r2) {
    return massageCore(JSON.parse(JSON.stringify(r2)));
  };

  massaged = function(f) {
    return function(err, data) {
      if (err) {
        return f(err);
      } else {
        return f(null, massage(data));
      }
    };
  };

  propagate = function(callback, f) {
    return function() {
      var args, err;
      err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (err) {
        return callback(err);
      } else {
        return f.apply(this, args);
      }
    };
  };

  getKeys = function(data, target, prefix) {
    var valids;
    if (target == null) {
      target = [];
    }
    if (prefix == null) {
      prefix = '';
    }
    valids = ['Array', 'String', 'Boolean', 'Date', 'Number', 'Null'];
    Object.keys(data).forEach(function(key) {
      if (valids.some(function(x) {
        return _(data[key])['is' + x]();
      })) {
        return target.push(prefix + key);
      } else {
        return getKeys(data[key], target, prefix + key + '.');
      }
    });
    return target;
  };

  exports.create = function() {
    var Mixed, ObjectID, ObjectId, Schema, api, defModels, getMeta, insertOps, internalListSub, key, makeModel, metaData, models, mongoose, nullablesValidation, preRemoveCascadeNonNullable, preRemoveCascadeNullable, specTransform, specmodels;
    if (process.env.NODE_ENV !== 'production') {
      for (key in require.cache) {
        delete require.cache[key];
      }
    }
    mongoose = require('mongoose');
    Schema = mongoose.Schema;
    Mixed = mongoose.Schema.Types.Mixed;
    ObjectID = mongoose.mongo.ObjectID;
    ObjectId = mongoose.Schema.ObjectId;
    api = {};
    models = {};
    specmodels = {};
    metaData = null;
    makeModel = function(connection, name, schema) {
      var ss;
      ss = new Schema(schema, {
        strict: true
      });
      ss.set('versionKey', false);
      return connection.model(name, ss, name);
    };
    getMeta = function(modelName) {
      return metaData[modelName];
    };
    nullablesValidation = function(schema) {
      return function(next) {
        var nonNullOuters, outers, paths, self;
        self = this;
        paths = schema.paths;
        outers = Object.keys(paths).filter(function(x) {
          return paths[x].options.type === ObjectId && typeof paths[x].options.ref === 'string' && !paths[x].options['x-owner'];
        }).map(function(x) {
          return {
            plur: paths[x].options.ref,
            sing: x,
            validation: paths[x].options['x-validation']
          };
        });
        nonNullOuters = outers.filter(function(x) {
          return self[x.sing] != null;
        });
        return async.forEach(nonNullOuters, function(o, callback) {
          return api.getOne(o.plur, {
            id: self[o.sing]
          }, function(err, data) {
            if (err || !data) {
              return callback(new Error("Invalid pointer"));
            } else if (o.validation) {
              return o.validation(self, data, function(err) {
                return callback(err ? new Error(err) : void 0);
              });
            } else {
              return callback();
            }
          });
        }, next);
      };
    };
    internalListSub = function(model, outer, id, filter, callback) {
      var finalFilter;
      if ((filter[outer] != null) && filter[outer].toString() !== id.toString()) {
        callback(new Error('No such id'));
        return;
      }
      filter = preprocFilter(filter);
      finalFilter = _.extend({}, filter, _.object([[outer, id]]));
      return models[model].find(finalFilter, callback);
    };
    preRemoveCascadeNonNullable = function(owner, id, next) {
      var manys;
      manys = getMeta(owner.modelName).manyToMany;
      return async.forEach(manys, function(many, callback) {
        var obj;
        obj = _.object([[many.inverseName, id]]);
        return models[many.ref].update(obj, {
          $pull: obj
        }, callback);
      }, function(err) {
        var flattenedModels;
        if (err) {
          return next(err);
        }
        flattenedModels = getMeta(owner.modelName).owns;
        return async.forEach(flattenedModels, function(mod, callback) {
          return internalListSub(mod.name, mod.field, id, {}, propagate(callback, function(data) {
            return async.forEach(data, function(item, callback) {
              return item.remove(callback);
            }, callback);
          }));
        }, next);
      });
    };
    preRemoveCascadeNullable = function(owner, id, next) {
      var flattenedModels, ownedModels;
      ownedModels = Object.keys(models).map(function(modelName) {
        var paths;
        paths = models[modelName].schema.paths;
        return Object.keys(paths).filter(function(x) {
          return paths[x].options.type === ObjectId && paths[x].options.ref === owner.modelName && !paths[x].options['x-owner'];
        }).map(function(x) {
          return {
            name: modelName,
            field: x
          };
        });
      });
      flattenedModels = _.flatten(ownedModels);
      return async.forEach(flattenedModels, function(mod, callback) {
        return internalListSub(mod.name, mod.field, id, {}, propagate(callback, function(data) {
          return async.forEach(data, function(item, callback) {
            item[mod.field] = null;
            item.save();
            return callback();
          }, callback);
        }));
      }, next);
    };
    specTransform = function(allspec, modelName, tgt, src, keys) {
      return keys.forEach(function(key) {
        if (src[key].type === 'mixed') {
          return tgt[key] = {
            type: Mixed
          };
        } else if (src[key].type === 'nested') {
          tgt[key] = {};
          return specTransform(allspec, modelName, tgt[key], src[key], _.without(Object.keys(src[key]), 'type'));
        } else if (src[key].type === 'string') {
          tgt[key] = _.extend({}, src[key], {
            type: String
          });
          if (src[key].validate != null) {
            return tgt[key].validate = function(value, callback) {
              return src[key].validate(api, value, callback);
            };
          }
        } else if (src[key].type === 'number') {
          return tgt[key] = _.extend({}, src[key], {
            type: Number
          });
        } else if (src[key].type === 'date') {
          return tgt[key] = _.extend({}, src[key], {
            type: Date
          });
        } else if (src[key].type === 'boolean') {
          return tgt[key] = _.extend({}, src[key], {
            type: Boolean
          });
        } else if (src[key].type === 'hasOne') {
          return tgt[key] = {
            ref: src[key].model,
            'x-validation': src[key].validation
          };
        } else if (src[key].type === 'hasMany') {
          tgt[key] = [
            {
              type: ObjectId,
              ref: src[key].model,
              inverseName: src[key].inverseName
            }
          ];
          return allspec[src[key].model][src[key].inverseName] = [
            {
              type: ObjectId,
              ref: modelName,
              inverseName: key
            }
          ];
        }
      });
    };
    defModels = function(models) {
      var allspec, newrest, toDef;
      specmodels = tools.desugar(models);
      toDef = [];
      newrest = {};
      allspec = {};
      Object.keys(specmodels).forEach(function(modelName) {
        return allspec[modelName] = {};
      });
      Object.keys(specmodels).forEach(function(modelName) {
        var inspec, owners, spec;
        spec = allspec[modelName];
        owners = specmodels[modelName].owners || {};
        inspec = specmodels[modelName].fields || {};
        specTransform(allspec, modelName, spec, inspec, Object.keys(inspec));
        return newrest[modelName] = _.extend({}, specmodels[modelName], {
          fields: spec
        });
      });
      Object.keys(newrest).forEach(function(modelName) {
        var conf;
        conf = newrest[modelName];
        Object.keys(conf.owners).forEach(function(ownerName) {
          return conf.fields[ownerName] = {
            type: ObjectId,
            ref: conf.owners[ownerName],
            required: true,
            'x-owner': true
          };
        });
        Object.keys(conf.indirectOwners).forEach(function(p) {
          return conf.fields[p] = {
            type: ObjectId,
            ref: conf.indirectOwners[p],
            required: true,
            'x-indirect-owner': true
          };
        });
        Object.keys(conf.fields).forEach(function(fieldName) {
          if (conf.fields[fieldName].ref != null) {
            return conf.fields[fieldName].type = ObjectId;
          }
        });
        return toDef.push([modelName, newrest[modelName]]);
      });
      metaData = tools.getMeta(specmodels);
      return toDef;
    };
    (function() {
      var connection;
      connection = null;
      api.connect = function(databaseUrl, inputModels, callback) {
        try {
          connection = mongoose.createConnection(databaseUrl);
          defModels(inputModels).forEach(function(_arg) {
            var name, v;
            name = _arg[0], v = _arg[1];
            models[name] = makeModel(connection, name, v.fields);
            models[name].schema.pre('save', nullablesValidation(models[name].schema));
            models[name].schema.pre('remove', function(next) {
              return preRemoveCascadeNonNullable(models[name], this._id.toString(), next);
            });
            return models[name].schema.pre('remove', function(next) {
              return preRemoveCascadeNullable(models[name], this._id.toString(), next);
            });
          });
        } catch (ex) {
          callback(ex);
          return;
        }
        return callback();
      };
      return api.close = function(callback) {
        connection.close();
        return callback();
      };
    })();
    api.post = function(model, indata, callback) {
      var owners, ownersOwners, ownersRaw, saveFunc;
      saveFunc = function(data) {
        return new models[model](data).save(function(err) {
          var fieldMatch, valueMatch;
          if (err && err.code === 11000) {
            fieldMatch = err.err.match(/([a-zA-Z]+)_1/);
            valueMatch = err.err.match(/"([a-zA-Z]+)"/);
            if (fieldMatch && valueMatch) {
              return callback(new Error("Duplicate value '" + valueMatch[1] + "' for " + fieldMatch[1]));
            } else {
              return callback(new Error("Unique constraint violated"));
            }
          } else {
            return massaged(callback).apply(this, arguments);
          }
        });
      };
      ownersRaw = getMeta(model).owners;
      owners = _(ownersRaw).pluck('plur');
      ownersOwners = _.flatten(owners.map(function(x) {
        return getMeta(x).owners;
      }));
      if (ownersOwners.length === 0) {
        return saveFunc(indata);
      } else {
        return api.getOne(owners[0], {
          filter: {
            id: indata[ownersRaw[0].sing]
          }
        }, propagate(callback, function(ownerdata) {
          var metaFields, paths;
          paths = models[owners[0]].schema.paths;
          metaFields = Object.keys(paths).filter(function(key) {
            return !!paths[key].options['x-owner'] || !!paths[key].options['x-indirect-owner'];
          });
          metaFields.forEach(function(key) {
            return indata[key] = ownerdata[key];
          });
          return saveFunc(indata);
        }));
      }
    };
    api.list = function(model, filter, callback) {
      var defaultSort, rr;
      filter = preprocFilter(filter);
      defaultSort = specmodels[model].defaultSort;
      rr = models[model].find(filter);
      if (defaultSort != null) {
        rr = rr.sort(_.object([[defaultSort, 'asc']]));
      }
      return rr.exec(massaged(callback));
    };
    api.getOne = function(model, config, callback) {
      var filter;
      filter = preprocFilter(config.filter || {});
      return models[model].findOne(filter, function(err, data) {
        if (err) {
          if (err.toString() === 'Error: Invalid ObjectId') {
            callback(new Error('No such id'));
          } else {
            callback(err);
          }
        } else if (!(data != null)) {
          return callback(new Error('No match'));
        } else {
          return callback(null, massage(data));
        }
      });
    };
    api.delOne = function(model, filter, callback) {
      filter = preprocFilter(filter);
      return models[model].findOne(filter, function(err, d) {
        if (err) {
          if (err.toString() === 'Error: Invalid ObjectId') {
            return callback(new Error('No such id'));
          } else {
            return callback(err);
          }
        } else if (!(d != null)) {
          return callback(new Error('No such id'));
        } else {
          return d.remove(function(err) {
            return callback(err, !err ? massage(d) : void 0);
          });
        }
      });
    };
    api.putOne = function(modelName, data, filter, callback) {
      var inputFields, inputFieldsValid, invalidFields, model, validField;
      filter = preprocFilter(filter);
      model = models[modelName];
      inputFieldsValid = getKeys(data);
      inputFields = Object.keys(data);
      validField = Object.keys(model.schema.paths);
      invalidFields = _.difference(inputFieldsValid, validField);
      if (invalidFields.length > 0) {
        callback(new Error("Invalid fields: " + invalidFields.join(', ')));
        return;
      }
      return model.findOne(filter, function(err, d) {
        if (err != null) {
          if (err.message === 'Invalid ObjectId') {
            callback(new Error("No such id"));
          } else {
            callback(err);
          }
          return;
        }
        if (!(d != null)) {
          callback(new Error("No such id"));
          return;
        }
        inputFields.forEach(function(key) {
          return d[key] = data[key];
        });
        return d.save(function(err) {
          return callback(err, err ? null : massage(d));
        });
      });
    };
    api.delMany = function(primaryModel, primaryId, propertyName, secondaryId, callback) {
      var inverseName, mm, secondaryModel;
      mm = getMeta(primaryModel).manyToMany.filter(function(x) {
        return x.name === propertyName;
      })[0];
      if (!(mm != null)) {
        callback(new Error('Invalid many-to-many property'));
        return;
      }
      secondaryModel = mm.ref;
      inverseName = mm.inverseName;
      return async.forEach([
        {
          model: primaryModel,
          id: primaryId,
          property: propertyName,
          secondaryId: secondaryId
        }, {
          model: secondaryModel,
          id: secondaryId,
          property: inverseName,
          secondaryId: primaryId
        }
      ], function(item, callback) {
        return models[item.model].findById(item.id, propagate(callback, function(data) {
          var conditions, options, update;
          conditions = {
            _id: item.id
          };
          update = {
            $pull: _.object([[item.property, item.secondaryId]])
          };
          options = {};
          return models[item.model].update(conditions, update, options, function(err, numAffected) {
            return callback(err);
          });
        }));
      }, callback);
    };
    insertOps = [];
    api.postMany = function(primaryModel, primaryId, propertyName, secondaryId, callback) {
      var hasAlready, insertOpMatch, insertOpNow, inverseName, mm, secondaryModel;
      mm = getMeta(primaryModel).manyToMany.filter(function(x) {
        return x.name === propertyName;
      })[0];
      if (!(mm != null)) {
        callback(new Error('Invalid many-to-many property'));
        return;
      }
      secondaryModel = mm.ref;
      inverseName = mm.inverseName;
      insertOpNow = [
        {
          primaryModel: primaryModel,
          primaryId: primaryId,
          propertyName: propertyName,
          secondaryId: secondaryId
        }, {
          primaryModel: secondaryModel,
          primaryId: secondaryId,
          propertyName: inverseName,
          secondaryId: primaryId
        }
      ];
      insertOpMatch = function(x1, x2) {
        return x1.primaryModel === x2.primaryModel && x1.primaryId === x2.primaryId && x1.propertyName === x2.propertyName && x1.secondaryId === x2.secondaryId;
      };
      hasAlready = insertOps.some(function(x) {
        return insertOpNow.some(function(y) {
          return insertOpMatch(x, y);
        });
      });
      if (hasAlready) {
        callback(null, {
          status: 'insert already in progress'
        });
        return;
      }
      insertOpNow.forEach(function(op) {
        return insertOps.push(op);
      });
      return async.map(insertOpNow, function(item, callback) {
        return models[item.primaryModel].findById(item.primaryId, callback);
      }, propagate(callback, function(datas) {
        var updated;
        updated = [false, false];
        insertOpNow.forEach(function(conf, i) {
          if (-1 === datas[i][conf.propertyName].indexOf(conf.secondaryId)) {
            datas[i][conf.propertyName].push(conf.secondaryId);
            return updated[i] = true;
          }
        });
        return async.forEach([0, 1], function(index, callback) {
          if (updated[index]) {
            return datas[index].save(callback);
          } else {
            return callback();
          }
        }, function(err) {
          if (err) {
            return callback(err);
          }
          insertOps = insertOps.filter(function(x) {
            return !_(insertOpNow).contains(x);
          });
          return callback(null, {
            status: (updated.some(function(x) {
              return x;
            }) ? 'inserted' : 'already inserted')
          });
        });
      }));
    };
    api.getMany = function(primaryModel, primaryId, propertyName, callback) {
      return models[primaryModel].findOne({
        _id: primaryId
      }).populate(propertyName).exec(function(err, story) {
        return callback(err, massage(story[propertyName]));
      });
    };
    return api;
  };

}).call(this);
