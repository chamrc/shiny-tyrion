// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var desugarModel, getAllIndirectOwners, getAllOwners, _,
    __slice = [].slice;

  _ = require('underscore');

  desugarModel = function(modelName, tgt, src, keys) {
    return keys.forEach(function(key) {
      var obj;
      if (typeof src[key] === 'string') {
        obj = {};
        obj[key] = {
          type: src[key]
        };
        return desugarModel(modelName, tgt, obj, [key]);
      } else if (!(src[key].type != null)) {
        throw new Error("must assign a type: " + key);
      } else if (src[key].type === 'mixed') {
        return tgt[key] = {
          type: 'mixed'
        };
      } else if (src[key].type === 'nested') {
        tgt[key] = {
          type: 'nested'
        };
        return desugarModel(modelName, tgt[key], src[key], _.without(Object.keys(src[key]), 'type'));
      } else if (_(['string', 'number', 'date', 'boolean']).contains(src[key].type)) {
        tgt[key] = {
          type: src[key].type,
          required: !!src[key].required,
          index: !!src[key].index,
          unique: !!src[key].unique
        };
        if (src[key]["default"] != null) {
          tgt[key]["default"] = src[key]["default"];
        }
        if (src[key].validate != null) {
          return tgt[key].validate = src[key].validate;
        }
      } else if (src[key].type === 'hasOne') {
        return tgt[key] = src[key];
      } else if (src[key].type === 'hasMany') {
        tgt[key] = src[key];
        return tgt[key].inverseName = src[key].inverseName || key;
      } else {
        throw new Error("Invalid type: " + src[key].type);
      }
    });
  };

  getAllOwners = function(specmodels, modelName) {
    var indirect, owners;
    owners = specmodels[modelName].owners;
    indirect = _.values(owners).map(function(model) {
      return getAllOwners(specmodels, model);
    });
    return _.extend.apply(_, [{}, owners].concat(__slice.call(indirect)));
  };

  getAllIndirectOwners = function(specmodels, modelName) {
    var indirect, owners;
    owners = specmodels[modelName].owners;
    indirect = _.flatten(_.values(owners).map(function(model) {
      return getAllOwners(specmodels, model);
    }));
    return _.extend.apply(_, [{}].concat(__slice.call(indirect)));
  };

  exports.desugar = function(models) {
    var rest;
    rest = {};
    Object.keys(models).forEach(function(modelName) {
      var inspec, spec;
      spec = {};
      inspec = models[modelName].fields || {};
      desugarModel(modelName, spec, inspec, Object.keys(inspec));
      rest[modelName] = _.extend({}, models[modelName], {
        fields: spec
      });
      if (!rest[modelName].owners) {
        return rest[modelName].owners = {};
      }
    });
    Object.keys(rest).forEach(function(modelName) {
      return rest[modelName].indirectOwners = getAllIndirectOwners(rest, modelName);
    });
    return rest;
  };

  exports.getMeta = function(specmodels) {
    var meta;
    meta = {};
    Object.keys(specmodels).forEach(function(modelName) {
      var apa, otherMany, ownMany;
      meta[modelName] = meta[modelName] || {};
      meta[modelName].owners = _.pairs(specmodels[modelName].owners).map(function(_arg) {
        var plur, sing;
        sing = _arg[0], plur = _arg[1];
        return {
          sing: sing,
          plur: plur
        };
      });
      meta[modelName].fields = [
        {
          name: 'id',
          readonly: true,
          required: false,
          type: 'string'
        }
      ];
      meta[modelName].fields = meta[modelName].fields.concat(_.pairs(specmodels[modelName].fields).filter(function(_arg) {
        var k, v;
        k = _arg[0], v = _arg[1];
        return v.type !== 'hasMany';
      }).map(function(_arg) {
        var k, v;
        k = _arg[0], v = _arg[1];
        return {
          name: k,
          readonly: k === '_id',
          required: !!v.require,
          type: v.type
        };
      }));
      meta[modelName].fields = meta[modelName].fields.concat(_.pairs(specmodels[modelName].owners).map(function(_arg) {
        var k, v;
        k = _arg[0], v = _arg[1];
        return {
          name: k,
          readonly: true,
          required: true,
          type: 'string'
        };
      }));
      meta[modelName].fields = meta[modelName].fields.concat(_.pairs(specmodels[modelName].indirectOwners).map(function(_arg) {
        var k, v;
        k = _arg[0], v = _arg[1];
        return {
          name: k,
          readonly: true,
          required: true,
          type: 'string'
        };
      }));
      meta[modelName].fields = _.sortBy(meta[modelName].fields, function(x) {
        return x.name;
      });
      apa = function(modelName) {
        return _.pairs(specmodels[modelName].fields).filter(function(_arg) {
          var key, value;
          key = _arg[0], value = _arg[1];
          return value.type === 'hasMany';
        });
      };
      ownMany = apa(modelName).map(function(_arg) {
        var k, v;
        k = _arg[0], v = _arg[1];
        return {
          ref: v.model,
          name: k,
          inverseName: v.inverseName
        };
      });
      otherMany = Object.keys(specmodels).map(function(mn) {
        var fd;
        fd = apa(mn).filter(function(_arg) {
          var k, v;
          k = _arg[0], v = _arg[1];
          return v.model === modelName;
        });
        return fd.map(function(_arg) {
          var k, v;
          k = _arg[0], v = _arg[1];
          return {
            ref: mn,
            name: v.inverseName,
            inverseName: k
          };
        });
      });
      return meta[modelName].manyToMany = _.flatten(ownMany.concat(otherMany));
    });
    Object.keys(meta).forEach(function(metaName) {
      return meta[metaName].owns = _.flatten(Object.keys(meta).map(function(mn) {
        return meta[mn].owners.filter(function(x) {
          return x.plur === metaName;
        }).map(function(x) {
          return {
            name: mn,
            field: x.sing
          };
        });
      }));
    });
    return meta;
  };

}).call(this);
