// Generated by CoffeeScript 1.6.3
(function() {
  var escodegen, estools, ftools, tools, _;

  _ = require('underscore');

  escodegen = require('escodegen');

  tools = require('./tools');

  estools = require('./estools');

  ftools = require('./jscoverage-formatting-tools');

  exports.formatTree = function(ast) {
    ftools.evalLiterals(ast, [
      {
        test: function(node) {
          return node.type === 'UnaryExpression' && node.argument.type === 'Literal' && node.operator === '!';
        },
        "eval": function(node) {
          return !node.argument.value;
        }
      }, {
        test: function(node) {
          return node.type === 'UnaryExpression' && node.argument.type === 'Literal' && node.operator === "~" && typeof node.argument.value === 'number';
        },
        "eval": function(node) {
          return ~node.argument.value;
        }
      }, {
        test: function(node) {
          return node.type === 'BinaryExpression' && node.left.type === 'Literal' && node.right.type === 'Literal' && typeof node.left.value === 'string' && typeof node.right.value === 'string' && node.operator === '+';
        },
        "eval": function(node) {
          return node.left.value + node.right.value;
        }
      }, {
        test: function(node) {
          var _ref;
          return node.type === 'BinaryExpression' && ftools.isNumericLiteral(node.left) && ftools.isNumericLiteral(node.right) && ((_ref = node.operator) === '+' || _ref === '-' || _ref === '*' || _ref === '%' || _ref === '/' || _ref === '<<' || _ref === '>>' || _ref === '>>>') && typeof ftools.evalLiteral(node.left) === 'number' && typeof ftools.evalLiteral(node.right) === 'number';
        },
        "eval": function(node) {
          return ftools.evalBinaryExpression(ftools.evalLiteral(node.left), node.operator, ftools.evalLiteral(node.right));
        }
      }
    ]);
    estools.traverse(ast, ['MemberExpression'], function(node) {
      var _ref;
      if (node.property.type === 'Literal' && ftools.isValidIdentifier(node.property.value)) {
        node.computed = false;
        node.property = {
          type: 'Identifier',
          name: node.property.value
        };
      }
      if (node.property.type === 'Literal' && ((_ref = node.property.value) != null ? _ref.toString().match(/^[1-9][0-9]*$/) : void 0)) {
        node.computed = true;
        node.property = estools.createLiteral(parseInt(node.property.value, 10));
      }
      if (node.property.type === 'Identifier' && ftools.isReservedWord(node.property.name)) {
        node.computed = true;
        return node.property = estools.createLiteral(node.property.name);
      }
    });
    estools.traverse(ast, function(node) {
      var _ref;
      if (((_ref = node.test) != null ? _ref.type : void 0) === 'Literal') {
        if (node.type === 'ConditionalExpression') {
          if (typeof node.test.value === 'string' || typeof node.test.value === 'number' || typeof node.test.value === 'boolean') {
            if (node.test.value) {
              return tools.replaceProperties(node, node.consequent);
            } else {
              return tools.replaceProperties(node, node.alternate);
            }
          }
        } else if (node.type === 'WhileStatement') {
          return node.test.value = !!node.test.value;
        } else if (node.type === 'DoWhileStatement') {
          return node.test.value = !!node.test.value;
        } else if (node.type === 'ForStatement') {
          if (node.test.value) {
            return node.test = null;
          } else {
            return node.test.value = false;
          }
        }
      }
    });
    ftools.replaceNegativeInfinities(ast);
    ftools.replacePositiveInfinities(ast);
    estools.traverse(ast, ['BlockStatement', 'Program'], function(node) {
      return node.body = node.body.filter(function(x, i) {
        var _ref;
        return !(x.type === 'EmptyStatement' && i - 1 >= 0 && ((_ref = node.body[i - 1].type) === 'ReturnStatement' || _ref === 'VariableDeclaration' || _ref === 'ExpressionStatement') && node.body[i - 1].loc.end.line === x.loc.start.line);
      });
    });
    estools.traverse(ast, ['BlockStatement', 'Program'], function(node) {
      return node.body = _.flatten(node.body.map(function(x, i) {
        if (x.type === 'IfStatement' && x.test.type === 'Literal') {
          if (x.test.value) {
            if (x.consequent.type === 'BlockStatement') {
              return x.consequent.body;
            } else {
              return _.extend({}, x.consequent, {
                loc: x.loc
              });
            }
          } else if (x.alternate) {
            if (x.alternate.type === 'BlockStatement') {
              return x.alternate.body;
            } else {
              return _.extend({}, x.alternate, {
                loc: x.loc
              });
            }
          } else {
            return [];
          }
        } else {
          return x;
        }
      }));
    });
    return estools.traverse(ast, ['FunctionExpression', 'FunctionDeclaration', 'Program'], function(node) {
      var body;
      body = node.type === 'Program' ? node.body : node.body.body;
      return body.filter(function(x) {
        return x.type === 'VariableDeclaration' && x.kind === 'let';
      }).forEach(function(stm) {
        return stm.kind = 'var';
      });
    });
  };

  exports.postFormatTree = function(ast) {
    var stored;
    stored = [];
    estools.traverse(ast, ['BlockStatement'], function(node) {
      if (node.body.some(function(stm) {
        return stm.type === 'VariableDeclaration' && stm.kind === 'let';
      })) {
        return stored.push(node);
      }
    });
    return stored.forEach(function(node) {
      return node.body = [
        {
          type: 'BlockStatement',
          body: node.body,
          loc: node.loc
        }
      ];
    });
  };

}).call(this);
