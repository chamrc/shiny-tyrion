// Generated by CoffeeScript 1.6.3
(function() {
  var estools, nodeIsInfinity, nodeIsNumericLiteral, nodeIsUnaryMinus, numberProperty, replaceAllNodes, replaceWithLiteral, reservedWords, tools;

  tools = require('./tools');

  estools = require('./estools');

  reservedWords = ['break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'false', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'null', 'return', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'abstract', 'boolean', 'byte', 'char', 'double', 'final', 'float', 'goto', 'implements', 'int', 'interface', 'long', 'native', 'package', 'private', 'protected', 'public', 'short', 'static', 'synchronized', 'throws', 'transient', 'export'];

  nodeIsInfinity = function(node) {
    return node.type === 'Literal' && node.value === Infinity;
  };

  nodeIsNumericLiteral = function(node) {
    return node.type === 'Literal' && typeof node.value === 'number';
  };

  nodeIsUnaryMinus = function(node) {
    return node.type === 'UnaryExpression' && node.operator === '-';
  };

  numberProperty = function(property) {
    return {
      type: 'MemberExpression',
      computed: false,
      object: {
        type: 'Identifier',
        name: 'Number'
      },
      property: {
        type: 'Identifier',
        name: property
      }
    };
  };

  replaceAllNodes = function(_arg) {
    var ast, predicate, replacement;
    ast = _arg.ast, predicate = _arg.predicate, replacement = _arg.replacement;
    return estools.traverse(ast, function(node) {
      if (predicate(node)) {
        return tools.replaceProperties(node, replacement(node));
      }
    });
  };

  replaceWithLiteral = function(node, value) {
    return tools.replaceProperties(node, estools.createLiteral(value));
  };

  exports.isNumericLiteral = function(node) {
    return nodeIsNumericLiteral(node) || (nodeIsUnaryMinus(node) && nodeIsNumericLiteral(node.argument));
  };

  exports.replaceNegativeInfinities = function(ast) {
    return replaceAllNodes({
      ast: ast,
      predicate: function(node) {
        return nodeIsUnaryMinus(node) && nodeIsInfinity(node.argument);
      },
      replacement: function() {
        return numberProperty('NEGATIVE_INFINITY');
      }
    });
  };

  exports.replacePositiveInfinities = function(ast) {
    return replaceAllNodes({
      ast: ast,
      predicate: nodeIsInfinity,
      replacement: function() {
        return numberProperty('POSITIVE_INFINITY');
      }
    });
  };

  exports.isReservedWord = (function() {
    var reservedWordsHash;
    reservedWordsHash = reservedWords.reduce(function(acc, word) {
      acc[word] = 1;
      return acc;
    }, {});
    return function(name) {
      return !!reservedWordsHash.hasOwnProperty(name);
    };
  })();

  exports.isValidIdentifier = function(name) {
    return (name != null ? name.toString().match(/^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/) : void 0) && !exports.isReservedWord(name);
  };

  exports.evalBinaryExpression = (function() {
    var methods;
    methods = {
      '+': function(x, y) {
        return x + y;
      },
      '-': function(x, y) {
        return x - y;
      },
      '*': function(x, y) {
        return x * y;
      },
      '%': function(x, y) {
        return x % y;
      },
      '/': function(x, y) {
        return x / y;
      },
      '<<': function(x, y) {
        return x << y;
      },
      '>>': function(x, y) {
        return x >> y;
      },
      '>>>': function(x, y) {
        return x >>> y;
      }
    };
    return function(arg1, op, arg2) {
      var method;
      method = methods[op];
      if (method == null) {
        throw "operator not supported";
      }
      return method(arg1, arg2);
    };
  })();

  exports.evalLiterals = function(ast, evals) {
    var format, _results;
    format = true;
    _results = [];
    while (format) {
      format = false;
      _results.push(estools.traverse(ast, function(node) {
        return evals.forEach(function(n) {
          var v;
          if (n.test(node)) {
            v = n["eval"](node);
            if (typeof v === 'number' && isNaN(v)) {
              tools.replaceProperties(node, {
                type: 'MemberExpression',
                computed: false,
                object: {
                  type: 'Identifier',
                  name: 'Number'
                },
                property: {
                  type: 'Identifier',
                  name: 'NaN'
                }
              });
            } else {
              replaceWithLiteral(node, v);
            }
            return format = true;
          }
        });
      }));
    }
    return _results;
  };

  exports.evalLiteral = function(node) {
    if (nodeIsNumericLiteral(node)) {
      return node.value;
    } else if (nodeIsUnaryMinus(node) && nodeIsNumericLiteral(node.argument)) {
      return -node.argument.value;
    } else {
      throw "not a numeric literal";
    }
  };

}).call(this);
