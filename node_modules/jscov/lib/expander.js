// Generated by CoffeeScript 1.6.3
(function() {
  var escodegen, esprima, estools, noopDef, noopExpression, tools, wrapLogic, wrapPred, _;

  _ = require('underscore');

  estools = require('./estools');

  tools = require('./tools');

  esprima = require('esprima');

  escodegen = require('escodegen');

  noopDef = function(name) {
    return {
      kind: 'var',
      type: 'VariableDeclaration',
      declarations: [
        {
          type: 'VariableDeclarator',
          id: {
            type: 'Identifier',
            name: name
          },
          init: {
            type: 'FunctionExpression',
            id: null,
            params: [],
            defaults: [],
            body: {
              type: 'BlockStatement',
              body: [
                {
                  type: 'ReturnStatement',
                  argument: {
                    type: 'Literal',
                    value: null
                  }
                }
              ]
            }
          },
          rest: null,
          generator: false,
          expression: false
        }
      ]
    };
  };

  noopExpression = function(name) {
    return {
      type: 'ExpressionStatement',
      expression: {
        "arguments": [],
        type: 'CallExpression',
        callee: {
          type: 'Identifier',
          name: name
        }
      }
    };
  };

  wrapPred = function(test, left, right) {
    return {
      type: 'CallExpression',
      "arguments": [
        {
          type: 'ThisExpression'
        }, {
          type: 'Identifier',
          name: 'arguments'
        }
      ],
      callee: {
        type: 'MemberExpression',
        computed: false,
        property: {
          type: 'Identifier',
          name: 'call'
        },
        object: {
          type: 'FunctionExpression',
          id: null,
          rest: null,
          generator: false,
          expression: false,
          params: [
            {
              type: 'Identifier',
              name: 'arguments'
            }
          ],
          defaults: [],
          body: {
            type: 'BlockStatement',
            body: [
              {
                type: 'IfStatement',
                test: test,
                consequent: {
                  type: 'ReturnStatement',
                  argument: left
                },
                alternate: {
                  type: 'ReturnStatement',
                  argument: right
                }
              }
            ]
          }
        }
      }
    };
  };

  wrapLogic = function(isAnd, left, right, tmpvar) {
    var l, r, res;
    l = isAnd ? right : {
      type: 'Identifier',
      name: tmpvar
    };
    r = !isAnd ? right : {
      type: 'Identifier',
      name: tmpvar
    };
    res = wrapPred({
      type: 'Identifier',
      name: tmpvar
    }, l, r);
    res.callee.object.body.body = [
      {
        kind: 'var',
        type: 'VariableDeclaration',
        declarations: [
          {
            type: 'VariableDeclarator',
            id: {
              type: 'Identifier',
              name: tmpvar
            },
            init: left
          }
        ]
      }
    ].concat(res.callee.object.body.body);
    return res;
  };

  exports.expand = function(ast) {
    var addNoop;
    if (typeof ast === 'string') {
      return escodegen.generate(exports.expand(esprima.parse(ast, {
        loc: false
      })), {
        indent: "  "
      });
    }
    addNoop = false;
    estools.traverse(ast, ['IfStatement'], function(node) {
      if (node.alternate == null) {
        addNoop = true;
        return node.alternate = noopExpression('__noop__');
      }
    });
    estools.traverse(ast, ['LogicalExpression'], function(node) {
      if (node.operator === '&&' || node.operator === '||') {
        if (node.left.type === 'Literal' || node.left.type === 'Identifier') {
          if (node.operator === '&&') {
            tools.replaceProperties(node, wrapPred(node.left, node.right, node.left));
          } else {
            tools.replaceProperties(node, wrapPred(node.left, node.left, node.right));
          }
        } else {
          tools.replaceProperties(node, wrapLogic(node.operator === '&&', node.left, node.right, '__lhs__'));
        }
        delete node.operator;
        delete node.left;
        return delete node.right;
      }
    });
    estools.traverse(ast, ['ConditionalExpression'], function(node) {
      tools.replaceProperties(node, wrapPred(node.test, node.consequent, node.alternate));
      delete node.test;
      delete node.consequent;
      return delete node.alternate;
    });
    if (addNoop) {
      estools.traverse(ast, ['Program'], function(node) {
        return node.body = [noopDef('__noop__')].concat(node.body);
      });
    }
    return ast;
  };

}).call(this);
