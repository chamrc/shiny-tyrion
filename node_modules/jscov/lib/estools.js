// Generated by CoffeeScript 1.6.3
(function() {
  var computedMember, escodegen, tools, _;

  escodegen = require('escodegen');

  tools = require('./tools');

  _ = require('underscore');

  exports.createLiteral = function(value) {
    if (typeof value === 'number' && value < 0) {
      return {
        type: 'UnaryExpression',
        operator: '-',
        argument: {
          type: 'Literal',
          value: -value
        }
      };
    } else {
      return {
        type: 'Literal',
        value: value
      };
    }
  };

  computedMember = function(_arg) {
    var object, property;
    property = _arg.property, object = _arg.object;
    return {
      type: 'MemberExpression',
      computed: true,
      property: property,
      object: object
    };
  };

  exports.coverageNode = function(node, filename, identifier) {
    return {
      type: 'ExpressionStatement',
      expression: {
        type: 'UpdateExpression',
        operator: '++',
        prefix: false,
        argument: computedMember({
          property: exports.createLiteral(node.loc.start.line),
          object: computedMember({
            property: exports.createLiteral(filename),
            object: {
              type: 'Identifier',
              name: identifier
            }
          })
        })
      }
    };
  };

  exports.traverse = function(ast, filter, callback) {
    if (callback == null) {
      callback = filter;
      filter = [];
    }
    return escodegen.traverse(ast, {
      enter: function(node) {
        if (filter.length === 0 || filter.indexOf(node.type) !== -1) {
          return callback(node);
        }
      }
    });
  };

  exports.addBeforeEveryStatement = function(ast, addback) {
    exports.traverse(ast, function(node) {
      if (node.type === 'IfStatement') {
        ['consequent', 'alternate'].forEach(function(path) {
          if ((node[path] != null) && node[path].type !== 'BlockStatement') {
            return node[path] = {
              type: 'BlockStatement',
              body: [node[path]]
            };
          }
        });
      }
      if (['ForInStatement', 'ForStatement', 'WhileStatement', 'WithStatement', 'DoWhileStatement'].indexOf(node.type) !== -1 && (node.body != null) && node.body.type !== 'BlockStatement') {
        return node.body = {
          type: 'BlockStatement',
          body: [node.body]
        };
      }
    });
    return exports.traverse(ast, function(node) {
      if (['BlockStatement', 'Program'].indexOf(node.type) !== -1) {
        node.body = _.flatten(node.body.map(function(statement) {
          var _ref, _ref1;
          if (((_ref = statement.expression) != null ? _ref.type : void 0) === 'FunctionExpression') {
            return [addback(statement.expression), statement];
          } else if (((_ref1 = statement.expression) != null ? _ref1.type : void 0) === 'CallExpression') {
            return [addback(statement.expression), statement];
          } else if (statement.type === 'FunctionDeclaration') {
            return [addback(statement.body), statement];
          } else {
            return [addback(statement), statement];
          }
        }));
      }
      if (node.type === 'SwitchCase') {
        return node.consequent = _.flatten(node.consequent.map(function(statement) {
          return [addback(statement), statement];
        }));
      }
    });
  };

}).call(this);
